# Anoma Protocol Adapter GraphQL Schema
# Entities follow Anoma specification from pa-evm/contracts/src/Types.sol

# ============================================
# Enums
# ============================================

# Status of resource blob decoding
enum DecodingStatus {
  pending   # Blob not yet received or processed
  raw       # Blob received but format is application-specific
  success   # Blob successfully decoded
  failed    # Blob decoding failed
}

# Blob deletion criterion from PA-EVM Logic.DeletionCriterion
enum DeletionCriterion {
  immediately  # Blob should be deleted after processing (value: 0)
  never        # Blob should be persisted permanently (value: 1)
}

# Payload type indicator
enum PayloadKind {
  discovery     # DiscoveryPayload - data with public keys for discovery
  forwarder     # ExternalPayload - data for external/forwarder calls
  application   # ApplicationPayload - application-specific data
}

# ============================================
# EVM Types
# ============================================

# EVMTransaction - The EVM transaction that carries the Anoma transaction
# This represents the blockchain carrier/wrapper, not the Anoma payload.
# Note: 1:1 relationship with Transaction, linked via Transaction.evmTransaction
type EVMTransaction {
  id: ID!  # Format: {chainId}_{txHash}
  txHash: String!
  blockNumber: Int!
  timestamp: Int!
  chainId: Int!

  # EVM transaction metadata
  from: String
  value: BigInt
  gasPrice: BigInt
  gas: BigInt
  gasUsed: BigInt
}

# ============================================
# Core Anoma Types
# ============================================

# Transaction - The Anoma transaction payload embedded in an EVM transaction
# Corresponds to: struct Transaction { Action[] actions; bytes deltaProof; bytes aggregationProof; }
type Transaction {
  id: ID!  # Format: {chainId}_{txHash}
  logIndex: Int!  # EVM event log index of the TransactionExecuted event
  contractAddress: String!

  # From TransactionExecuted event
  tags: [String!]!
  logicRefs: [String!]!

  # Proofs (from calldata decoding)
  deltaProof: String
  aggregationProof: String

  # Relationship to EVM carrier
  evmTransaction: EVMTransaction!

  # Relationships (note: resources is a convenience, canonical path is via actions/complianceUnits)
  actions: [Action!]! @derivedFrom(field: "transaction")
  resources: [Resource!]! @derivedFrom(field: "transaction")
}

# Action - Provides context separation between non-intersecting sets of resources
# Corresponds to: struct Action { Logic.VerifierInput[] logicVerifierInputs; Compliance.VerifierInput[] complianceVerifierInputs; }
type Action {
  id: ID!
  index: Int!
  actionTreeRoot: String!
  tagCount: Int!
  blockNumber: Int!
  chainId: Int!
  timestamp: Int!

  # Relationships
  transaction: Transaction!
  complianceUnits: [ComplianceUnit!]! @derivedFrom(field: "action")
  logicInputs: [LogicInput!]! @derivedFrom(field: "action")
}

# ComplianceUnit - One consumed + one created resource pair
# Corresponds to: Compliance.VerifierInput { bytes proof; Instance instance; }
type ComplianceUnit {
  id: ID!
  index: Int!

  # Proof
  proof: String

  # Compliance.Instance fields
  # ConsumedRefs
  consumedNullifier: String!
  consumedLogicRef: String!
  consumedCommitmentTreeRoot: String!

  # CreatedRefs
  createdCommitment: String!
  createdLogicRef: String!

  # Delta values (secp256k1 point)
  unitDeltaX: String!
  unitDeltaY: String!

  # Relationships
  action: Action!
  consumedResource: Resource
  createdResource: Resource
}

# LogicInput - Logic verifier input for a resource
# Corresponds to: Logic.VerifierInput { bytes32 tag; bytes32 verifyingKey; AppData appData; bytes proof; }
type LogicInput {
  id: ID!
  index: Int!

  tag: String!
  logicRef: String! # The logic verifying key (same as verifyingKey in PA-EVM)
  isConsumed: Boolean!
  proof: String

  # AppData payload counts
  resourcePayloadCount: Int!
  discoveryPayloadCount: Int!
  externalPayloadCount: Int!
  applicationPayloadCount: Int!

  # Relationships
  action: Action!
  resource: Resource
}

# Resource - A reference to an Anoma resource identified by its tag (nullifier or commitment)
# Note: The full Resource struct fields (labelRef, valueRef, etc.) cannot be populated
# because the ResourcePayload blob format is application-specific.
type Resource {
  id: ID!
  tag: String! # Nullifier (if consumed) or commitment (if created)
  index: Int! # Position in TransactionExecuted.tags array
  blobIndex: Int # Index in ResourcePayload event (if emitted)
  isConsumed: Boolean! # true = nullifier (consumed), false = commitment (created)
  blockNumber: Int!
  chainId: Int!

  # Logic reference from TransactionExecuted.logicRefs
  logicRef: String

  # Raw blob data from ResourcePayload event (if emitted)
  rawBlob: String!
  decodingStatus: DecodingStatus!
  decodingError: String

  # Relationships
  transaction: Transaction!
  logicInput: LogicInput
  complianceUnit: ComplianceUnit # The compliance unit this resource belongs to (use isConsumed to determine side)
  payloads: [Payload!]! @derivedFrom(field: "resource")
}

# ============================================
# Payload Types (from events)
# ============================================

# Unified Payload type for all payload events (Discovery, External, Application)
# Note: blockNumber, chainId, timestamp can be accessed via resource.transaction
type Payload {
  id: ID!
  kind: PayloadKind!  # Discriminator for payload type
  tag: String!
  index: Int!
  blob: String!
  deletionCriterion: DeletionCriterion

  resource: Resource
}

# ============================================
# State Tracking Types
# ============================================

# CommitmentTreeRoot - Merkle tree root for resource commitments
type CommitmentTreeRoot {
  id: ID!
  root: String!
  blockNumber: Int!
  txHash: String!
  timestamp: Int!
  chainId: Int!
  index: Int!
}

# ForwarderCall - Meta-transaction execution via untrusted forwarder
type ForwarderCall {
  id: ID!
  forwarderAddress: String!
  input: String!
  output: String!
  blockNumber: Int!
  txHash: String!
  timestamp: Int!
  chainId: Int!
}
